{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83e\udd80 Rust \u2192 C# Developer Handbook","text":"<p>Welcome to the Rust to C# Developer Handbook \u2014 a practical, example-driven reference for translating low-level and systems-focused Rust code into modern, idiomatic C# using .NET 8+.</p> <p>Whether you're: - Porting an unsafe binary parser, - Wrapping native Rust libraries for .NET interop, - Learning Rust from a C# perspective, - Or building fast, safe CLI tools in either language \u2014</p> <p>This guide is designed to make the transition smooth, structured, and insightful.</p>"},{"location":"#whats-inside","title":"\ud83e\udded What's Inside","text":"<p>The handbook is organized into grouped sections for fast navigation:</p>"},{"location":"#language-syntax","title":"\ud83e\uddf1 Language &amp; Syntax","text":"<p>Understand variables, types, control flow, and pattern matching.</p>"},{"location":"#types-traits","title":"\ud83e\udde9 Types &amp; Traits","text":"<p>Map Rust structs and traits to C# classes and interfaces, including generics and inheritance.</p>"},{"location":"#memory-runtime","title":"\u2699\ufe0f Memory &amp; Runtime","text":"<p>Ownership, error handling, nullability, collections, and working with serialized data.</p>"},{"location":"#async-concurrency","title":"\ud83d\ude80 Async &amp; Concurrency","text":"<p>Translate async/await, background tasks, and shared-state concurrency between ecosystems.</p>"},{"location":"#tooling-build","title":"\ud83d\udd27 Tooling &amp; Build","text":"<p>Compare Cargo and .NET CLI, setup CI/CD pipelines, use analyzers and source generators.</p>"},{"location":"#binary-file-parsing","title":"\ud83d\udd22 Binary File Parsing","text":"<p>Read and write binary formats with idiomatic, safe code \u2014 in both Rust and C#.</p>"},{"location":"#testing-advanced","title":"\ud83e\uddea Testing &amp; Advanced","text":"<p>Write unit tests, run benchmarks, and apply low-level performance tricks.</p>"},{"location":"#resources","title":"\ud83d\udcd8 Resources","text":"<ul> <li>\ud83d\udcd1 Glossary / Quick Reference</li> <li>\ud83d\udd01 From C# to Rust</li> <li>\ud83e\uddea Real Project Examples</li> </ul>"},{"location":"#how-it-works","title":"\ud83e\udde0 How It Works","text":"<p>Every section includes: - \ud83d\udd04 Side-by-side syntax comparisons - \ud83e\uddea Real-world examples in Rust and C# - \ud83e\udde0 Conceptual mappings of language features - \ud83d\udcdd Edge-case notes for memory safety, null handling, trait behavior, etc.</p>"},{"location":"#who-its-for","title":"\ud83d\udc69\u200d\ud83d\udcbb Who It's For","text":"<ul> <li>Rust devs building GUI tools, web apps, or interop layers in C#</li> <li>C# devs learning safe systems-level programming with Rust</li> <li>Teams migrating code, porting CLI utilities, or writing cross-platform libraries</li> </ul>"},{"location":"#goals","title":"\u2728 Goals","text":"<ul> <li>Eliminate confusion with a clean, consistent reference format</li> <li>Help you write idiomatic, production-quality C# or Rust by example</li> <li>Make porting between the two ecosystems approachable \u2014 and fun</li> </ul> <p>If you find something missing or unclear \u2014 open an issue or contribute!</p> <p>Let\u2019s make Rust and C# a developer-friendly duo. \ud83e\udd80 \ud83e\udd1d \ud83e\udde9</p>"},{"location":"advanced-topics/","title":"\u2699\ufe0f Advanced Topics","text":""},{"location":"advanced-topics/#unsafe-code","title":"\ud83d\udd12 Unsafe Code","text":"Rust C# <code>unsafe {}</code> <code>unsafe {}</code> <code>*const T</code> <code>T*</code>"},{"location":"advanced-topics/#example","title":"\ud83e\uddea Example","text":"<pre><code>unsafe {\n    let ptr = &amp;10 as *const i32;\n    println!(\"{}\", *ptr);\n}\n</code></pre> <pre><code>unsafe {\n    int x = 10;\n    int* ptr = &amp;x;\n    Console.WriteLine(*ptr);\n}\n</code></pre>"},{"location":"advanced-topics/#macros","title":"\ud83e\udde0 Macros","text":"<p>Rust: <pre><code>macro_rules! say_hello {\n    () =&gt; { println!(\"Hello!\") };\n}\n</code></pre></p> <p>C#: use Roslyn source generators or code snippets.</p>"},{"location":"async-concurrency/","title":"\ud83d\ude80 Async &amp; Concurrency","text":""},{"location":"async-concurrency/#asyncawait","title":"\ud83d\udd01 async/await","text":"Rust C# <code>async fn foo()</code> <code>async Task Foo()</code> <code>.await</code> <code>.Await()</code>"},{"location":"async-concurrency/#example","title":"\ud83e\uddea Example","text":"<pre><code>async fn say_hi() {\n    println!(\"Hi!\");\n}\n</code></pre> <pre><code>async Task SayHi() {\n    Console.WriteLine(\"Hi!\");\n}\n</code></pre>"},{"location":"async-concurrency/#spawning-tasks","title":"\ud83e\uddf5 Spawning Tasks","text":"<pre><code>tokio::spawn(async {\n    do_work().await;\n});\n</code></pre> <pre><code>Task.Run(async () =&gt; await DoWork());\n</code></pre>"},{"location":"benchmarks/","title":"\u23f1\ufe0f Benchmarks &amp; Performance Testing: Rust vs C","text":"<p>Both Rust and C# support benchmarking frameworks to help you measure performance accurately and reproducibly.</p>"},{"location":"benchmarks/#rust-cargo-bench-with-criterion","title":"\ud83e\udd80 Rust: <code>cargo bench</code> with Criterion","text":""},{"location":"benchmarks/#setup-with-criterion","title":"Setup with Criterion","text":"<p>Add to <code>Cargo.toml</code>:</p> <pre><code>[dev-dependencies]\ncriterion = \"0.5\"\n</code></pre>"},{"location":"benchmarks/#example","title":"Example","text":"<pre><code>use criterion::{criterion_group, criterion_main, Criterion};\n\nfn fibonacci(n: u64) -&gt; u64 {\n    match n {\n        0 =&gt; 1,\n        1 =&gt; 1,\n        n =&gt; fibonacci(n - 1) + fibonacci(n - 2),\n    }\n}\n\nfn bench_fib(c: &amp;mut Criterion) {\n    c.bench_function(\"fib 20\", |b| b.iter(|| fibonacci(20)));\n}\n\ncriterion_group!(benches, bench_fib);\ncriterion_main!(benches);\n</code></pre> <p>Run with:</p> <pre><code>cargo bench\n</code></pre>"},{"location":"benchmarks/#c-benchmarkdotnet","title":"\ud83d\udcbb C#: BenchmarkDotNet","text":""},{"location":"benchmarks/#setup","title":"Setup","text":"<p>Add NuGet package:</p> <pre><code>dotnet add package BenchmarkDotNet\n</code></pre>"},{"location":"benchmarks/#example_1","title":"Example","text":"<pre><code>using BenchmarkDotNet.Attributes;\nusing BenchmarkDotNet.Running;\n\npublic class FibonacciBenchmarks\n{\n    [Benchmark]\n    public int Fibonacci20() =&gt; Fibonacci(20);\n\n    public int Fibonacci(int n) =&gt;\n        n switch\n        {\n            0 =&gt; 1,\n            1 =&gt; 1,\n            _ =&gt; Fibonacci(n - 1) + Fibonacci(n - 2)\n        };\n}\n\nBenchmarkRunner.Run&lt;FibonacciBenchmarks&gt;();\n</code></pre> <p>Run with:</p> <pre><code>dotnet run -c Release\n</code></pre>"},{"location":"benchmarks/#output-comparison","title":"\ud83d\udcca Output Comparison","text":"Feature Rust (<code>criterion</code>) C# (<code>BenchmarkDotNet</code>) CLI Command <code>cargo bench</code> <code>dotnet run -c Release</code> Baseline Support \u2705 Yes \u2705 Yes Histogram Output \u2705 Yes \u2705 Yes HTML Reports \u2705 Yes (optional) \u2705 Yes Statistical Analysis \u2705 Built-in \u2705 Built-in Async Benchmarks Limited support \u2705 Yes"},{"location":"benchmarks/#summary","title":"\ud83d\udcdd Summary","text":"Task Rust C# Add dependency <code>criterion</code> in dev-deps <code>BenchmarkDotNet</code> via NuGet Define benchmark function <code>fn</code> with <code>c.bench_function</code> <code>[Benchmark]</code> attribute Execute benchmark <code>cargo bench</code> <code>dotnet run -c Release</code> Output CLI + charts (optional) Console + charts + markdown <p>Both ecosystems provide high-quality benchmarking tools \u2014 Rust focuses on precision and minimalism, while C# offers rich reports and IDE integration.</p>"},{"location":"build-deployment/","title":"\ud83d\ude80 Build &amp; Deployment Pipelines: Rust vs C","text":"<p>This section compares how Rust and C# handle project builds, CI/CD pipelines, and multi-target packaging.</p>"},{"location":"build-deployment/#project-structure","title":"\ud83d\udee0\ufe0f Project Structure","text":"Feature Rust C# (.NET) Build Tool <code>cargo</code> <code>dotnet</code> Solution Format N/A (workspaces in TOML) <code>.sln</code> + <code>.csproj</code> Config File <code>Cargo.toml</code> <code>.csproj</code>, <code>.sln</code> Test Target <code>cargo test</code> <code>dotnet test</code> Publish Target <code>cargo build --release</code> <code>dotnet publish</code>"},{"location":"build-deployment/#building-a-release-binary","title":"\ud83d\udce6 Building a Release Binary","text":""},{"location":"build-deployment/#rust","title":"Rust","text":"<pre><code>cargo build --release\n</code></pre> <p>Output: - <code>target/release/your_app</code></p>"},{"location":"build-deployment/#c","title":"C","text":"<pre><code>dotnet publish -c Release -r win-x64 --self-contained\n</code></pre> <p>Output: - <code>bin/Release/net8.0/win-x64/publish/</code></p>"},{"location":"build-deployment/#running-tests","title":"\ud83e\uddea Running Tests","text":""},{"location":"build-deployment/#rust_1","title":"Rust","text":"<pre><code>cargo test\n</code></pre>"},{"location":"build-deployment/#c_1","title":"C","text":"<pre><code>dotnet test\n</code></pre>"},{"location":"build-deployment/#watch-for-changes","title":"\ud83d\udd01 Watch for Changes","text":""},{"location":"build-deployment/#rust_2","title":"Rust","text":"<pre><code>cargo watch -x run\n</code></pre> <p>Install with:</p> <pre><code>cargo install cargo-watch\n</code></pre>"},{"location":"build-deployment/#c_2","title":"C","text":"<pre><code>dotnet watch run\n</code></pre>"},{"location":"build-deployment/#multi-project-setup","title":"\ud83e\uddf1 Multi-Project Setup","text":""},{"location":"build-deployment/#rust_3","title":"Rust","text":"<pre><code>[workspace]\nmembers = [\"core\", \"utils\", \"cli\"]\n</code></pre>"},{"location":"build-deployment/#c_3","title":"C","text":"<pre><code>dotnet new sln\ndotnet sln add src/Core/Core.csproj\ndotnet sln add src/CLI/CLI.csproj\n</code></pre>"},{"location":"build-deployment/#cicd-example-github-actions","title":"\u2699\ufe0f CI/CD Example: GitHub Actions","text":""},{"location":"build-deployment/#rust_4","title":"Rust","text":"<pre><code>jobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Install Rust\n      uses: actions-rs/toolchain@v1\n      with:\n        toolchain: stable\n    - run: cargo build --release\n</code></pre>"},{"location":"build-deployment/#c_4","title":"C","text":"<pre><code>jobs:\n  build:\n    runs-on: windows-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Setup .NET\n      uses: actions/setup-dotnet@v3\n      with:\n        dotnet-version: '8.0.x'\n    - run: dotnet restore\n    - run: dotnet build --configuration Release\n</code></pre>"},{"location":"build-deployment/#static-analysis-linting","title":"\ud83e\uddea Static Analysis &amp; Linting","text":"Tool Type Rust C# (.NET) Linter <code>cargo clippy</code> Roslyn analyzers Format Code <code>cargo fmt</code> <code>dotnet format</code> Audit Packages <code>cargo audit</code> <code>dotnet list package --vulnerable</code>"},{"location":"build-deployment/#summary","title":"\ud83d\udcdd Summary","text":"Action Rust C# Build <code>cargo build</code> <code>dotnet build</code> Test <code>cargo test</code> <code>dotnet test</code> Release <code>cargo build --release</code> <code>dotnet publish -c Release</code> CI Tooling GitHub Actions, CLI GitHub Actions, Azure DevOps Static Analysis <code>clippy</code>, <code>fmt</code>, <code>audit</code> Roslyn, <code>dotnet format</code> <p>Rust\u2019s <code>cargo</code> provides a unified workflow, while .NET\u2019s ecosystem is more modular but deeply integrated with IDEs and enterprise pipelines.</p>"},{"location":"collections-iterators/","title":"\ud83d\udcda Collections &amp; Iterators","text":""},{"location":"collections-iterators/#common-types","title":"\ud83d\udce6 Common Types","text":"Rust C# <code>Vec&lt;T&gt;</code> <code>List&lt;T&gt;</code> <code>HashMap&lt;K, V&gt;</code> <code>Dictionary&lt;K,V&gt;</code>"},{"location":"collections-iterators/#iterators","title":"\ud83d\udd01 Iterators","text":"Rust C# <code>vec.iter()</code> <code>list.Select(...)</code> <code>filter()</code>, <code>map()</code> <code>Where()</code>, <code>Select()</code>"},{"location":"collections-iterators/#example","title":"\ud83e\uddea Example","text":"<pre><code>let nums = vec![1, 2, 3];\nlet doubled: Vec&lt;i32&gt; = nums.iter().map(|x| x * 2).collect();\n</code></pre> <pre><code>var nums = new List&lt;int&gt; { 1, 2, 3 };\nvar doubled = nums.Select(x =&gt; x * 2).ToList();\n</code></pre>"},{"location":"control-flow/","title":"\ud83d\udd01 Control Flow","text":"<p>Compare how conditional logic and loops are expressed in Rust vs C#.</p>"},{"location":"control-flow/#conditionals","title":"\ud83d\udd0d Conditionals","text":"Rust C# <code>if x &gt; 5 {}</code> <code>if (x &gt; 5) {}</code>"},{"location":"control-flow/#example","title":"\ud83e\uddea Example","text":"<pre><code>if x &gt; 5 {\n    println!(\"x is large!\");\n}\n</code></pre> <pre><code>if (x &gt; 5)\n{\n    Console.WriteLine(\"x is large!\");\n}\n</code></pre>"},{"location":"control-flow/#loops","title":"\ud83d\udd01 Loops","text":"Rust C# <code>for i in 0..10 {}</code> <code>for (int i = 0; i &lt; 10; i++)</code>"},{"location":"control-flow/#example_1","title":"\ud83e\uddea Example","text":"<pre><code>for i in 0..3 {\n    println!(\"{}\", i);\n}\n</code></pre> <pre><code>for (int i = 0; i &lt; 3; i++) {\n    Console.WriteLine(i);\n}\n</code></pre>"},{"location":"control-flow/#additional-control-flow","title":"\ud83d\udd01 Additional Control Flow","text":""},{"location":"control-flow/#while-loop","title":"\ud83e\uddea <code>while</code> Loop","text":"<pre><code>let mut i = 0;\nwhile i &lt; 5 {\n    println!(\"{}\", i);\n    i += 1;\n}\n</code></pre> <pre><code>int i = 0;\nwhile (i &lt; 5) {\n    Console.WriteLine(i);\n    i++;\n}\n</code></pre>"},{"location":"control-flow/#infinite-loop","title":"\ud83e\uddea Infinite Loop","text":"<pre><code>loop {\n    println!(\"looping forever\");\n}\n</code></pre> <pre><code>while (true) {\n    Console.WriteLine(\"looping forever\");\n}\n</code></pre>"},{"location":"dependency-management/","title":"\ud83d\udce6 Dependency Management: Rust Crates vs C# NuGet","text":"<p>Both Rust and C# use package managers to handle third-party libraries, dependencies, and tooling.</p>"},{"location":"dependency-management/#rust-cargo-cratesio","title":"\ud83d\udce6 Rust: Cargo &amp; crates.io","text":""},{"location":"dependency-management/#add-a-dependency","title":"Add a Dependency","text":"<p>Modify <code>Cargo.toml</code>:</p> <pre><code>[dependencies]\nserde = \"1.0\"\n</code></pre> <p>Then run:</p> <pre><code>cargo build\n</code></pre>"},{"location":"dependency-management/#update-all","title":"Update All","text":"<pre><code>cargo update\n</code></pre>"},{"location":"dependency-management/#search-for-a-crate","title":"Search for a Crate","text":"<pre><code>cargo search json\n</code></pre> <p>Or visit: https://crates.io</p>"},{"location":"dependency-management/#c-nuget-dotnet-cli","title":"\ud83d\udce6 C#: NuGet &amp; dotnet CLI","text":""},{"location":"dependency-management/#add-a-dependency_1","title":"Add a Dependency","text":"<pre><code>dotnet add package Newtonsoft.Json\n</code></pre> <p>This modifies your <code>.csproj</code> file:</p> <pre><code>&lt;ItemGroup&gt;\n  &lt;PackageReference Include=\"Newtonsoft.Json\" Version=\"13.0.1\" /&gt;\n&lt;/ItemGroup&gt;\n</code></pre>"},{"location":"dependency-management/#update-all-packages","title":"Update All Packages","text":"<pre><code>dotnet list package --outdated\ndotnet outdated\n</code></pre> <p>(use <code>dotnet-outdated</code> tool)</p>"},{"location":"dependency-management/#search-for-a-package","title":"Search for a Package","text":"<ul> <li>Use https://nuget.org</li> <li>Or: <code>dotnet search Newtonsoft.Json</code> (experimental)</li> </ul>"},{"location":"dependency-management/#feature-comparison","title":"\ud83d\udd01 Feature Comparison","text":"Feature Rust (Cargo) C# (.NET + NuGet) Package Registry crates.io nuget.org CLI Tool <code>cargo</code> <code>dotnet</code> Versioning Format Semver + optional ranges Semver + ranges/constraints Workspace Support \u2705 Native via <code>[workspace]</code> \u2705 Supported via <code>.sln</code> Lockfile <code>Cargo.lock</code> <code>packages.lock.json</code> (opt-in) Dependency Groups <code>[dependencies]</code>, <code>[dev-dependencies]</code> TargetFrameworks / Conditionals"},{"location":"dependency-management/#tooling-differences","title":"\ud83d\udee0 Tooling Differences","text":"Task Cargo .NET CLI Add dependency <code>cargo add serde</code> <code>dotnet add package Foo</code> Remove dependency <code>cargo remove serde</code> Manually edit <code>.csproj</code> Dependency graph <code>cargo tree</code> <code>dotnet list package</code> Audit dependencies <code>cargo audit</code> <code>dotnet list package --vulnerable</code> (preview)"},{"location":"dependency-management/#summary","title":"\ud83d\udcdd Summary","text":"Area Rust C# (.NET) Registry crates.io nuget.org Tool Cargo dotnet CLI Lockfile Cargo.lock packages.lock.json Dependency groups <code>[dependencies]</code> + <code>[dev-dependencies]</code> Conditional ItemGroups <p>Rust\u2019s package manager is tightly integrated and consistent, while .NET benefits from rich IDE tooling and a large package ecosystem.</p>"},{"location":"error-handling/","title":"\ud83d\udca5 Error Handling","text":""},{"location":"error-handling/#result-option","title":"\u2705 Result / Option","text":"Rust C# <code>Result&lt;T, E&gt;</code> <code>Result&lt;T&gt;</code> or try/catch <code>Option&lt;T&gt;</code> Nullable types / Optional"},{"location":"error-handling/#example","title":"\ud83e\uddea Example","text":"<pre><code>fn divide(x: i32, y: i32) -&gt; Result&lt;i32, String&gt; {\n    if y == 0 {\n        Err(\"division by zero\".to_string())\n    } else {\n        Ok(x / y)\n    }\n}\n</code></pre> <pre><code>int Divide(int x, int y) {\n    if (y == 0) throw new DivideByZeroException();\n    return x / y;\n}\n</code></pre>"},{"location":"error-handling/#panic-vs-exception","title":"\ud83d\udea8 Panic vs Exception","text":"<pre><code>panic!(\"Unexpected error!\");\n</code></pre> <pre><code>throw new Exception(\"Unexpected error!\");\n</code></pre>"},{"location":"ffi-interop/","title":"\ud83d\udd0c FFI &amp; Interop: Rust \u2194 C","text":"<p>Rust and C# can interoperate with each other and with C libraries using FFI (Foreign Function Interface) and platform interop mechanisms.</p>"},{"location":"ffi-interop/#rust-exposing-a-c-compatible-api","title":"\ud83e\udd80 Rust: Exposing a C-compatible API","text":""},{"location":"ffi-interop/#exporting-functions-from-rust","title":"Exporting Functions from Rust","text":"<pre><code>#[no_mangle]\npub extern \"C\" fn add(x: i32, y: i32) -&gt; i32 {\n    x + y\n}\n</code></pre> <ul> <li><code>#[no_mangle]</code> disables Rust name mangling</li> <li><code>extern \"C\"</code> uses the C calling convention</li> </ul>"},{"location":"ffi-interop/#compiling-as-a-dynamic-library","title":"Compiling as a Dynamic Library","text":"<pre><code>[lib]\ncrate-type = [\"cdylib\"]\n</code></pre> <p>Build with:</p> <pre><code>cargo build --release\n</code></pre> <p>This produces <code>.dll</code>, <code>.so</code>, or <code>.dylib</code> depending on platform.</p>"},{"location":"ffi-interop/#c-importing-from-rust-dll","title":"\ud83d\udcbb C#: Importing from Rust DLL","text":"<pre><code>using System.Runtime.InteropServices;\n\nclass NativeMethods {\n    [DllImport(\"mylib.dll\", CallingConvention = CallingConvention.Cdecl)]\n    public static extern int add(int x, int y);\n}\n</code></pre> <p>Call it:</p> <pre><code>Console.WriteLine(NativeMethods.add(2, 3)); // Outputs: 5\n</code></pre>"},{"location":"ffi-interop/#passing-strings","title":"\ud83d\udd01 Passing Strings","text":""},{"location":"ffi-interop/#rust-exporting-a-function-with-a-string","title":"Rust: Exporting a Function with a String","text":"<pre><code>#[no_mangle]\npub extern \"C\" fn greet(ptr: *const u8, len: usize) {\n    let slice = unsafe { std::slice::from_raw_parts(ptr, len) };\n    let input = std::str::from_utf8(slice).unwrap();\n    println!(\"Hello, {}\", input);\n}\n</code></pre>"},{"location":"ffi-interop/#c-marshaling-a-utf-8-string","title":"C#: Marshaling a UTF-8 String","text":"<pre><code>var bytes = Encoding.UTF8.GetBytes(\"Rusty\");\nunsafe {\n    fixed (byte* ptr = bytes) {\n        greet((IntPtr)ptr, bytes.Length);\n    }\n}\n</code></pre>"},{"location":"ffi-interop/#interop-tips","title":"\ud83e\udde0 Interop Tips","text":"Concept Rust C# Basic Function <code>extern \"C\" fn</code> <code>[DllImport(...)]</code> Structs <code>#[repr(C)] struct</code> <code>[StructLayout(LayoutKind.Sequential)]</code> String Passing <code>*const u8</code> + length <code>IntPtr</code> + <code>byte[]</code> Arrays Raw pointers (<code>*const T</code>) <code>Span&lt;T&gt;</code>, <code>IntPtr</code>, <code>fixed</code> Cleanup Manual free required <code>Marshal.FreeHGlobal</code> or manual"},{"location":"ffi-interop/#calling-c-from-rust-via-c","title":"\ud83d\udce4 Calling C# from Rust (via C)","text":"<p>This is harder and usually involves: - Creating a C ABI from C# - Calling via COM interop, C++/CLI, or hosting CLR manually</p> <p>For most use cases, Rust \u2192 C# is easier than the reverse.</p>"},{"location":"ffi-interop/#memory-safety-warnings","title":"\ud83d\udd12 Memory Safety Warnings","text":"<ul> <li>You must manage memory manually across the FFI boundary.</li> <li>Rust can safely handle <code>unsafe</code> code, but you must enforce it yourself.</li> <li>Avoid allocating or deallocating across boundaries unless both sides agree.</li> </ul>"},{"location":"ffi-interop/#summary","title":"\ud83d\udcdd Summary","text":"Direction Method Rust \u2192 C# Export Rust as <code>cdylib</code>, use <code>DllImport</code> in C# C# \u2192 Rust Much harder \u2014 via C wrapper or COM Safe Types Integers, structs, pointers, UTF-8 Avoid Passing heap-allocated strings or objects directly <p>FFI is powerful but sharp \u2014 test thoroughly and use stable interfaces across language boundaries.</p>"},{"location":"functions-generics/","title":"\ud83d\udce6 Functions &amp; Generics","text":""},{"location":"functions-generics/#functions","title":"\ud83d\udee0 Functions","text":"Rust Function C# Equivalent <code>fn add(x: i32, y: i32) -&gt; i32</code> <code>int Add(int x, int y)</code>"},{"location":"functions-generics/#example","title":"\ud83e\uddea Example","text":"<pre><code>fn add(x: i32, y: i32) -&gt; i32 {\n    x + y\n}\n</code></pre> <pre><code>int Add(int x, int y) {\n    return x + y;\n}\n</code></pre>"},{"location":"functions-generics/#generics","title":"\ud83d\udd23 Generics","text":"Rust C# <code>fn generic&lt;T&gt;(x: T)</code> <code>void Generic&lt;T&gt;(T x)</code>"},{"location":"functions-generics/#example_1","title":"\ud83e\uddea Example","text":"<pre><code>fn echo&lt;T: std::fmt::Debug&gt;(x: T) {\n    println!(\"{:?}\", x);\n}\n</code></pre> <pre><code>void Echo&lt;T&gt;(T x) {\n    Console.WriteLine(x);\n}\n</code></pre>"},{"location":"functions-generics/#trait-bounds-in-generics","title":"\ud83d\udccf Trait Bounds in Generics","text":""},{"location":"functions-generics/#rust","title":"Rust","text":"<pre><code>fn print_debug&lt;T: std::fmt::Debug&gt;(x: T) {\n    println!(\"{:?}\", x);\n}\n</code></pre>"},{"location":"functions-generics/#c","title":"C#","text":"<pre><code>void Print&lt;T&gt;(T x) where T : IFormattable {\n    Console.WriteLine(x);\n}\n</code></pre>"},{"location":"functions-generics/#functional-equivalents","title":"\ud83d\udd01 Functional Equivalents","text":""},{"location":"functions-generics/#c-delegates","title":"C# Delegates","text":"<pre><code>Func&lt;int, int&gt; square = x =&gt; x * x;\nAction&lt;string&gt; shout = msg =&gt; Console.WriteLine(msg);\n</code></pre>"},{"location":"glossary/","title":"\ud83d\udcd8 Glossary &amp; Quick Reference: Rust \u2192 C","text":"<p>This section provides a fast lookup table for translating Rust concepts, syntax, and types into their C# equivalents.</p>"},{"location":"glossary/#types","title":"\ud83d\udd24 Types","text":"Rust C# <code>i32</code>, <code>u32</code> <code>int</code>, <code>uint</code> <code>i64</code>, <code>u64</code> <code>long</code>, <code>ulong</code> <code>f32</code>, <code>f64</code> <code>float</code>, <code>double</code> <code>bool</code> <code>bool</code> <code>char</code> <code>char</code> (Unicode scalar) <code>String</code> / <code>&amp;str</code> <code>string</code> <code>Option&lt;T&gt;</code> <code>T?</code>, <code>Nullable&lt;T&gt;</code> <code>Result&lt;T, E&gt;</code> <code>try/catch</code>, custom types <code>Vec&lt;T&gt;</code> <code>List&lt;T&gt;</code> <code>HashMap&lt;K, V&gt;</code> <code>Dictionary&lt;K, V&gt;</code>"},{"location":"glossary/#structs-enums","title":"\ud83e\uddf1 Structs &amp; Enums","text":"Rust C# <code>struct</code> <code>class</code> or <code>struct</code> <code>enum</code> (algebraic types) <code>record</code>, <code>discriminated union</code> (manual) <code>#[derive(Debug)]</code> <code>ToString()</code> or source generator <code>impl Struct</code> C# methods in class"},{"location":"glossary/#traits-interfaces","title":"\ud83e\udde9 Traits &amp; Interfaces","text":"Rust C# <code>trait</code> <code>interface</code> <code>impl Trait for T</code> <code>class : Interface</code> <code>Default</code>, <code>Clone</code> <code>IDisposable</code>, <code>ICloneable</code>, etc. Trait bounds <code>where T : Interface</code>"},{"location":"glossary/#collections","title":"\ud83e\uddee Collections","text":"Rust C# <code>Vec&lt;T&gt;</code> <code>List&lt;T&gt;</code> <code>HashMap&lt;K, V&gt;</code> <code>Dictionary&lt;K, V&gt;</code> <code>.iter().map()</code> <code>.Select()</code> (LINQ) <code>.filter()</code> <code>.Where()</code> (LINQ) <code>.collect()</code> <code>.ToList()</code>, <code>.ToArray()</code>"},{"location":"glossary/#control-flow","title":"\ud83d\udd01 Control Flow","text":"Rust C# <code>if</code>, <code>else</code> <code>if</code>, <code>else</code> <code>match</code> <code>switch</code> <code>loop {}</code> <code>while (true)</code> <code>for x in y</code> <code>foreach (var x in y)</code> <code>while</code>, <code>break</code>, <code>continue</code> same"},{"location":"glossary/#error-handling","title":"\ud83e\udde0 Error Handling","text":"Rust C# <code>Result&lt;T, E&gt;</code> <code>try/catch</code> or <code>OneOf&lt;T,E&gt;</code> <code>?</code> operator <code>throw;</code> / unwrap pattern <code>panic!()</code> <code>throw Exception</code>"},{"location":"glossary/#project-structure-tooling","title":"\ud83d\udce6 Project Structure &amp; Tooling","text":"Rust (Cargo) C# (.NET CLI) <code>Cargo.toml</code> <code>.csproj</code>, <code>.sln</code> <code>cargo build</code> <code>dotnet build</code> <code>cargo test</code> <code>dotnet test</code> <code>cargo run</code> <code>dotnet run</code> <code>cargo fmt</code> <code>dotnet format</code>"},{"location":"glossary/#async-threads","title":"\ud83d\ude80 Async &amp; Threads","text":"Rust C# <code>async fn</code>, <code>.await</code> <code>async Task</code>, <code>await</code> <code>tokio::spawn</code> <code>Task.Run(...)</code> <code>thread::spawn</code> <code>new Thread(...).Start()</code> <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> <code>lock</code>, <code>SemaphoreSlim</code>, etc."},{"location":"glossary/#summary-cheat-sheet","title":"\ud83d\udcdd Summary Cheat Sheet","text":"Rust Concept C# Equivalent <code>trait</code> <code>interface</code> <code>Option&lt;T&gt;</code> <code>T?</code> or <code>Nullable&lt;T&gt;</code> <code>Result&lt;T, E&gt;</code> <code>try/catch</code> or wrapper <code>match</code> <code>switch</code> with patterns <code>macro_rules!</code> Source Generator / Helper <code>Cargo.toml</code> <code>.csproj</code> / NuGet <p>Use this glossary for quick reference while translating or porting code from Rust to C#.</p>"},{"location":"language-fundamentals/","title":"\ud83d\udd24 Language Fundamentals","text":"<p>This section compares core variable declarations, constants, and types in Rust and C#.</p>"},{"location":"language-fundamentals/#variables","title":"\ud83d\udd27 Variables","text":"Rust C# <code>let x = 5;</code> <code>var x = 5;</code> <code>let mut x = 5;</code> <code>int x = 5;</code>"},{"location":"language-fundamentals/#example","title":"\ud83e\uddea Example","text":"<pre><code>let x = 10;\nlet y = x + 5;\n</code></pre> <pre><code>var x = 10;\nvar y = x + 5;\n</code></pre>"},{"location":"language-fundamentals/#constants","title":"\ud83d\udd10 Constants","text":"Rust C# <code>const MAX: usize = 100;</code> <code>const int MAX = 100;</code>"},{"location":"language-fundamentals/#type-annotations","title":"\ud83e\udde0 Type Annotations","text":"Rust C# <code>let x: f32 = 5.0;</code> <code>float x = 5.0f;</code>"},{"location":"language-fundamentals/#extra-notes","title":"\ud83d\udcdd Extra Notes","text":"<ul> <li>Rust allows shadowing, meaning you can <code>let x = 1; let x = x + 1;</code></li> <li>You can use suffixes in Rust like <code>5.0f32</code>, <code>42u32</code> to specify type literals directly</li> </ul>"},{"location":"macros-vs-generators/","title":"\ud83e\uddf1 Macros vs Source Generators: Rust vs C","text":"<p>Rust macros and C# source generators both provide compile-time code generation, but they operate differently and serve different use cases.</p>"},{"location":"macros-vs-generators/#rust-macros","title":"\ud83e\udd80 Rust Macros","text":""},{"location":"macros-vs-generators/#declarative-macros-macro_rules","title":"Declarative Macros (<code>macro_rules!</code>)","text":"<pre><code>macro_rules! say_hello {\n    () =&gt; {\n        println!(\"Hello!\");\n    };\n}\n\nsay_hello!();\n</code></pre>"},{"location":"macros-vs-generators/#procedural-macros","title":"Procedural Macros","text":"<pre><code>#[derive(Debug)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n</code></pre> <p>Uses a <code>#[proc_macro_derive(Debug)]</code> in an external crate.</p>"},{"location":"macros-vs-generators/#c-source-generators-roslyn","title":"\ud83d\udcbb C# Source Generators (Roslyn)","text":"<p>Introduced in .NET 5+, these allow generating code during compilation.</p>"},{"location":"macros-vs-generators/#simple-example","title":"Simple Example","text":"<pre><code>[MyAutoNotify]\npublic partial class Person\n{\n    private string name;\n}\n</code></pre> <p>This uses a source generator that emits:</p> <pre><code>public string Name\n{\n    get =&gt; name;\n    set =&gt; SetProperty(ref name, value);\n}\n</code></pre>"},{"location":"macros-vs-generators/#comparison-table","title":"\u2699\ufe0f Comparison Table","text":"Feature Rust C# Declarative Macros <code>macro_rules!</code> N/A Procedural Macros <code>#[proc_macro]</code>, <code>#[derive]</code> <code>ISourceGenerator</code> Scope File/crate level Assembly level Runtime Use? No (compile-time only) No (compile-time only) IDE Support Often limited Full IntelliSense + preview Use Cases DSLs, Derive, function wrappers Auto-properties, DTOs, validations"},{"location":"macros-vs-generators/#use-cases","title":"\ud83d\udd27 Use Cases","text":"Scenario Rust C# Auto Traits <code>#[derive(Debug)]</code> <code>[AutoGenerateToString]</code> DSL Construction <code>macro_rules! html {}</code> \u2716 (Manual or external tooling) Reflection-free serialization <code>serde::Serialize</code> <code>System.Text.Json.SourceGenerator</code> Compile-time code validation <code>proc_macro_attribute</code> <code>ISourceGenerator</code> + analyzer"},{"location":"macros-vs-generators/#limitations","title":"\ud83d\udea7 Limitations","text":"<ul> <li>Rust macros are more flexible, but harder to debug and IDEs may struggle</li> <li>C# source generators are more structured, but limited to supported APIs</li> </ul>"},{"location":"macros-vs-generators/#summary","title":"\ud83d\udcdd Summary","text":"Rust C# <code>macro_rules!</code> Not available <code>#[derive()]</code>, <code>#[proc_macro]</code> <code>[Attribute]</code> + <code>partial class</code> + <code>ISourceGenerator</code> Compile-time only \u2705 <p>Both systems aim to reduce boilerplate and increase code clarity, but Rust takes a more syntax-level metaprogramming approach, while C# leans on structured Roslyn APIs.</p>"},{"location":"memory-ownership/","title":"\ud83e\udde0 Memory and Ownership","text":""},{"location":"memory-ownership/#ownership-borrowing","title":"\ud83d\udd01 Ownership &amp; Borrowing","text":"Rust C# Ownership model enforced GC handles memory <code>&amp;T</code>, <code>&amp;mut T</code> (borrows) <code>ref</code>, <code>out</code>, <code>in</code>"},{"location":"memory-ownership/#example","title":"\ud83e\uddea Example","text":"<pre><code>fn print_length(s: &amp;String) {\n    println!(\"{}\", s.len());\n}\n</code></pre> <pre><code>void PrintLength(in string s) {\n    Console.WriteLine(s.Length);\n}\n</code></pre>"},{"location":"memory-ownership/#drop-vs-dispose","title":"\ud83d\uddd1 Drop vs Dispose","text":"Rust C# <code>Drop</code> trait <code>IDisposable</code>"},{"location":"memory-ownership/#example_1","title":"\ud83e\uddea Example","text":"<pre><code>impl Drop for MyResource {\n    fn drop(&amp;mut self) {\n        println!(\"Cleaning up!\");\n    }\n}\n</code></pre> <pre><code>public class MyResource : IDisposable {\n    public void Dispose() {\n        Console.WriteLine(\"Cleaning up!\");\n    }\n}\n</code></pre>"},{"location":"modules-namespaces/","title":"\ud83e\udded Modules &amp; Namespaces","text":""},{"location":"modules-namespaces/#structure","title":"\ud83e\uddf1 Structure","text":"Rust C# <code>mod foo;</code> file-based or namespace <code>use crate::foo::bar;</code> <code>using Foo.Bar;</code>"},{"location":"modules-namespaces/#example","title":"\ud83e\uddea Example","text":"<pre><code>mod math {\n    pub fn add(x: i32, y: i32) -&gt; i32 {\n        x + y\n    }\n}\n</code></pre> <pre><code>namespace Math {\n    public static class Operations {\n        public static int Add(int x, int y) =&gt; x + y;\n    }\n}\n</code></pre>"},{"location":"pattern-matching/","title":"\ud83c\udfad Pattern Matching: Rust vs C","text":"<p>Rust and C# both support powerful pattern matching, but with very different syntax and paradigms.</p>"},{"location":"pattern-matching/#basic-match-vs-switch","title":"\ud83d\udd01 Basic <code>match</code> vs <code>switch</code>","text":""},{"location":"pattern-matching/#rust","title":"Rust","text":"<pre><code>let value = 3;\nmatch value {\n    1 =&gt; println!(\"One\"),\n    2 | 3 =&gt; println!(\"Two or Three\"),\n    4..=10 =&gt; println!(\"Between four and ten\"),\n    _ =&gt; println!(\"Something else\"),\n}\n</code></pre>"},{"location":"pattern-matching/#c","title":"C#","text":"<pre><code>int value = 3;\nswitch (value)\n{\n    case 1:\n        Console.WriteLine(\"One\");\n        break;\n    case 2 or 3:\n        Console.WriteLine(\"Two or Three\");\n        break;\n    case &gt;= 4 and &lt;= 10:\n        Console.WriteLine(\"Between four and ten\");\n        break;\n    default:\n        Console.WriteLine(\"Something else\");\n        break;\n}\n</code></pre>"},{"location":"pattern-matching/#matching-enums","title":"\ud83e\udde9 Matching Enums","text":""},{"location":"pattern-matching/#rust_1","title":"Rust","text":"<pre><code>enum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n}\n\nlet msg = Message::Move { x: 5, y: 10 };\n\nmatch msg {\n    Message::Quit =&gt; println!(\"Quit\"),\n    Message::Move { x, y } =&gt; println!(\"Move to ({}, {})\", x, y),\n}\n</code></pre>"},{"location":"pattern-matching/#c_1","title":"C#","text":"<pre><code>public record Message;\n\npublic record Quit : Message;\npublic record Move(int X, int Y) : Message;\n\nMessage msg = new Move(5, 10);\n\nswitch (msg)\n{\n    case Quit:\n        Console.WriteLine(\"Quit\");\n        break;\n    case Move(var x, var y):\n        Console.WriteLine($\"Move to ({x}, {y})\");\n        break;\n}\n</code></pre>"},{"location":"pattern-matching/#matching-with-if-conditions","title":"\u2753 Matching with <code>if</code> Conditions","text":""},{"location":"pattern-matching/#rust_2","title":"Rust","text":"<pre><code>let number = Some(7);\n\nif let Some(x) = number {\n    println!(\"Found: {}\", x);\n}\n</code></pre>"},{"location":"pattern-matching/#c_2","title":"C#","text":"<pre><code>int? number = 7;\n\nif (number is int x) {\n    Console.WriteLine($\"Found: {x}\");\n}\n</code></pre>"},{"location":"pattern-matching/#when-clauses-in-c","title":"\ud83e\udde0 <code>when</code> Clauses in C#","text":"<pre><code>switch (value)\n{\n    case int x when x % 2 == 0:\n        Console.WriteLine(\"Even\");\n        break;\n    case int x:\n        Console.WriteLine(\"Odd\");\n        break;\n}\n</code></pre> <p>Rust doesn\u2019t have this built-in, but you can use guards:</p> <pre><code>match value {\n    x if x % 2 == 0 =&gt; println!(\"Even\"),\n    _ =&gt; println!(\"Odd\"),\n}\n</code></pre>"},{"location":"pattern-matching/#summary","title":"\u2705 Summary","text":"Concept Rust (<code>match</code>) C# (<code>switch</code> + <code>is</code> + <code>when</code>) Pattern Matching <code>match</code> expression <code>switch</code> statement Range Patterns <code>4..=10</code> <code>&gt;= 4 and &lt;= 10</code> Enum Destructuring <code>Enum::Variant { fields }</code> <code>record</code> matching with properties Condition Matching <code>x if condition</code> <code>when</code> clause Nullable Matching <code>if let Some(x)</code> <code>if (obj is T x)</code> <p>Pattern matching is deeply embedded into Rust\u2019s design, while C# is catching up with modern pattern features in .NET 8.</p>"},{"location":"reading-binary-data/","title":"\ud83d\udd22 Reading Binary Data: Rust vs C","text":"<p>Reading binary data is a common task in both systems programming (Rust) and application development (C#). This guide maps syntax, patterns, and techniques between the two languages.</p>"},{"location":"reading-binary-data/#file-reading-setup","title":"\ud83d\udcc4 File Reading Setup","text":"Task Rust C# Open a file <code>let file = File::open(path)?;</code> <code>var stream = new FileStream(path, FileMode.Open);</code> Buffered read <code>let mut reader = BufReader::new(file);</code> <code>var reader = new BinaryReader(stream);</code> Traits needed <code>T: Read + Seek</code> <code>Stream</code>/<code>BinaryReader</code> supports all"},{"location":"reading-binary-data/#reading-primitive-types","title":"\ud83d\udd22 Reading Primitive Types","text":""},{"location":"reading-binary-data/#rust-with-byteorder-or-binread","title":"\ud83d\udce6 Rust (with <code>byteorder</code> or <code>binread</code>)","text":"<pre><code>use byteorder::{ReadBytesExt, LittleEndian};\n\nlet val = reader.read_u32::&lt;LittleEndian&gt;()?;\nlet val = reader.read_i16::&lt;LittleEndian&gt;()?;\n</code></pre>"},{"location":"reading-binary-data/#c","title":"\ud83e\udde0 C#","text":"<pre><code>uint val = reader.ReadUInt32();\nshort val = reader.ReadInt16();\n</code></pre>"},{"location":"reading-binary-data/#endianness","title":"\ud83d\udccf Endianness","text":"Rust C# <code>LittleEndian</code>, <code>BigEndian</code> from <code>byteorder</code> No built-in: use <code>BinaryPrimitives</code>, <code>BitConverter</code> Specify endianness per read Must swap bytes manually"},{"location":"reading-binary-data/#c-manual-example-bigendian","title":"\ud83d\udce6 C# Manual Example (BigEndian)","text":"<pre><code>byte[] bytes = reader.ReadBytes(4);\nint val = BitConverter.ToInt32(bytes.Reverse().ToArray());\n</code></pre>"},{"location":"reading-binary-data/#reading-strings","title":"\ud83e\uddf5 Reading Strings","text":""},{"location":"reading-binary-data/#rust","title":"\ud83d\udce6 Rust","text":"<pre><code>// Null-terminated string\nlet mut buf = Vec::new();\nreader.read_until(0, &amp;mut buf)?;\nlet s = String::from_utf8_lossy(&amp;buf[..buf.len()-1]).to_string();\n</code></pre>"},{"location":"reading-binary-data/#c_1","title":"\ud83e\udde0 C#","text":"<pre><code>// Null-terminated string\nList&lt;byte&gt; bytes = new();\nbyte b;\nwhile ((b = reader.ReadByte()) != 0)\n    bytes.Add(b);\nstring s = Encoding.UTF8.GetString(bytes.ToArray());\n</code></pre>"},{"location":"reading-binary-data/#reading-arrays-and-structs","title":"\ud83e\uddf1 Reading Arrays and Structs","text":""},{"location":"reading-binary-data/#rust_1","title":"\ud83d\udce6 Rust","text":"<pre><code>let mut arr = [0u8; 16];\nreader.read_exact(&amp;mut arr)?;\n</code></pre>"},{"location":"reading-binary-data/#c_2","title":"\ud83e\udde0 C#","text":"<pre><code>byte[] arr = reader.ReadBytes(16);\n</code></pre>"},{"location":"reading-binary-data/#reading-a-struct-manually","title":"Reading a Struct Manually","text":""},{"location":"reading-binary-data/#rust_2","title":"Rust","text":"<pre><code>let x = reader.read_u32::&lt;LittleEndian&gt;()?;\nlet y = reader.read_f32::&lt;LittleEndian&gt;()?;\n</code></pre>"},{"location":"reading-binary-data/#c_3","title":"C#","text":"<pre><code>uint x = reader.ReadUInt32();\nfloat y = reader.ReadSingle();\n</code></pre>"},{"location":"reading-binary-data/#seeking-in-streams","title":"\ud83e\udde9 Seeking in Streams","text":"Rust C# <code>reader.seek(SeekFrom::Start(n))</code> <code>stream.Seek(n, SeekOrigin.Begin);</code> <code>SeekFrom::Current(n)</code> <code>SeekOrigin.Current</code>"},{"location":"reading-binary-data/#binary-parsing-tips","title":"\ud83e\udde0 Binary Parsing Tips","text":"Task Rust C# Validate struct size Manual or <code>binread</code> Use offset math or span validation Skip bytes <code>reader.seek(SeekFrom::Current(n))</code> <code>reader.BaseStream.Seek(n, SeekOrigin.Current);</code> Read into model Field-by-field assignment Use method or custom parser class"},{"location":"reading-binary-data/#reusable-binary-readers","title":"\ud83d\udd01 Reusable Binary Readers","text":""},{"location":"reading-binary-data/#rust-trait-based","title":"Rust Trait-Based","text":"<pre><code>pub trait BinReadable {\n    fn read(reader: &amp;mut impl Read) -&gt; Result&lt;Self, Error&gt; where Self: Sized;\n}\n</code></pre>"},{"location":"reading-binary-data/#c-interface-based","title":"C# Interface-Based","text":"<pre><code>public interface IBinaryReadable {\n    void ReadFrom(BinaryReader reader);\n}\n</code></pre>"},{"location":"reading-binary-data/#example-reading-a-custom-header","title":"\ud83e\uddea Example: Reading a Custom Header","text":""},{"location":"reading-binary-data/#rust_3","title":"Rust","text":"<pre><code>let magic = reader.read_u32::&lt;LittleEndian&gt;()?;\nlet version = reader.read_u16::&lt;LittleEndian&gt;()?;\n</code></pre>"},{"location":"reading-binary-data/#c_4","title":"C#","text":"<pre><code>uint magic = reader.ReadUInt32();\nushort version = reader.ReadUInt16();\n</code></pre>"},{"location":"reading-binary-data/#summary","title":"\u2705 Summary","text":"Concept Rust C# Binary Reader <code>Read + Seek</code> <code>BinaryReader</code> Endianness <code>byteorder</code>, <code>binread</code> Manual or <code>BitConverter</code> Strings <code>read_until(0)</code> Loop until byte == 0 Arrays <code>read_exact()</code> <code>ReadBytes(n)</code> Structs Manual or macro-derived Manual or <code>IBinaryReadable</code> <p>This page serves as a reference for building binary file readers, game data parsers, and stream-based processing across Rust and C#.</p>"},{"location":"real-examples/","title":"\ud83e\uddea Real Project Examples","text":"<p>This section contains real-world Rust and C# code patterns side-by-side for common application scenarios.</p>"},{"location":"real-examples/#1-binary-file-parsing","title":"1\ufe0f\u20e3 Binary File Parsing","text":""},{"location":"real-examples/#rust","title":"Rust","text":"<pre><code>use std::fs::File;\nuse std::io::{Read, BufReader};\n\nfn read_header(path: &amp;str) -&gt; std::io::Result&lt;[u8; 4]&gt; {\n    let file = File::open(path)?;\n    let mut reader = BufReader::new(file);\n    let mut buffer = [0u8; 4];\n    reader.read_exact(&amp;mut buffer)?;\n    Ok(buffer)\n}\n</code></pre>"},{"location":"real-examples/#c","title":"C#","text":"<pre><code>using var reader = new BinaryReader(File.OpenRead(\"file.bin\"));\nbyte[] buffer = reader.ReadBytes(4);\n</code></pre>"},{"location":"real-examples/#2-async-http-client","title":"2\ufe0f\u20e3 Async HTTP Client","text":""},{"location":"real-examples/#rust-with-reqwest","title":"Rust with <code>reqwest</code>","text":"<pre><code>let res = reqwest::get(\"https://api.example.com/data\").await?;\nlet body = res.text().await?;\n</code></pre>"},{"location":"real-examples/#c-with-httpclient","title":"C# with <code>HttpClient</code>","text":"<pre><code>var response = await httpClient.GetAsync(\"https://api.example.com/data\");\nvar body = await response.Content.ReadAsStringAsync();\n</code></pre>"},{"location":"real-examples/#3-command-line-app","title":"3\ufe0f\u20e3 Command-Line App","text":""},{"location":"real-examples/#rust_1","title":"Rust","text":"<pre><code>fn main() {\n    let args: Vec&lt;String&gt; = std::env::args().collect();\n    println!(\"Hello, {}\", args.get(1).unwrap_or(&amp;\"World\".to_string()));\n}\n</code></pre>"},{"location":"real-examples/#c_1","title":"C#","text":"<pre><code>Console.WriteLine($\"Hello, {args.ElementAtOrDefault(0) ?? \"World\"}\");\n</code></pre>"},{"location":"real-examples/#4-configuration-file-json","title":"4\ufe0f\u20e3 Configuration File (JSON)","text":""},{"location":"real-examples/#rust_2","title":"Rust","text":"<pre><code>let config: Config = serde_json::from_str(&amp;fs::read_to_string(\"config.json\")?)?;\n</code></pre>"},{"location":"real-examples/#c_2","title":"C#","text":"<pre><code>var config = JsonSerializer.Deserialize&lt;Config&gt;(File.ReadAllText(\"config.json\"));\n</code></pre>"},{"location":"real-examples/#5-background-worker-task","title":"5\ufe0f\u20e3 Background Worker / Task","text":""},{"location":"real-examples/#rust_3","title":"Rust","text":"<pre><code>tokio::spawn(async {\n    println!(\"Running in background...\");\n});\n</code></pre>"},{"location":"real-examples/#c_3","title":"C#","text":"<pre><code>Task.Run(() =&gt; Console.WriteLine(\"Running in background...\"));\n</code></pre>"},{"location":"real-examples/#summary","title":"\ud83d\udd1a Summary","text":"Scenario Rust C# File Parsing <code>std::fs</code>, <code>BufReader</code> <code>BinaryReader</code>, <code>FileStream</code> HTTP Client <code>reqwest</code> <code>HttpClient</code> CLI Args <code>std::env::args()</code> <code>args[]</code> JSON Config <code>serde_json</code> <code>System.Text.Json</code> Background Task <code>tokio::spawn</code> <code>Task.Run()</code> <p>These patterns cover 80% of use cases in CLI tools, parsers, services, and utilities across both ecosystems.</p>"},{"location":"reverse-mapping/","title":"\ud83d\udd01 From C# to Rust: Reverse Concept Mapping","text":"<p>This section helps .NET developers understand how to translate familiar C# constructs into idiomatic Rust.</p>"},{"location":"reverse-mapping/#primitives-types","title":"\ud83e\udde0 Primitives &amp; Types","text":"C# Rust <code>int</code> <code>i32</code> <code>long</code> <code>i64</code> <code>float</code> <code>f32</code> <code>double</code> <code>f64</code> <code>string</code> <code>String</code>, <code>&amp;str</code> <code>bool</code> <code>bool</code> <code>List&lt;T&gt;</code> <code>Vec&lt;T&gt;</code> <code>Dictionary&lt;K,V&gt;</code> <code>HashMap&lt;K,V&gt;</code>"},{"location":"reverse-mapping/#classes-structs-enums","title":"\ud83e\uddf1 Classes, Structs, Enums","text":"C# Rust <code>class</code> <code>struct</code> or <code>enum</code> <code>struct</code> (value type) <code>#[derive(...)] struct</code> <code>record</code> <code>enum</code> or <code>struct</code> with traits <code>readonly struct</code> <code>Copy</code> + <code>Clone</code> trait"},{"location":"reverse-mapping/#interfaces-and-inheritance","title":"\ud83e\udde9 Interfaces and Inheritance","text":"C# Rust <code>interface</code> <code>trait</code> <code>implements</code> <code>impl Trait for Struct</code> Multiple interfaces Multiple trait impls Virtual methods Trait + default method"},{"location":"reverse-mapping/#control-flow","title":"\ud83d\udd01 Control Flow","text":"C# Rust <code>switch</code>, <code>when</code> <code>match</code> <code>if</code>, <code>else</code> <code>if</code>, <code>else</code> <code>foreach</code> <code>for x in y</code> <code>while</code> <code>while</code> <code>try</code>, <code>catch</code>, <code>finally</code> <code>Result&lt;T, E&gt;</code>, <code>?</code> operator"},{"location":"reverse-mapping/#nullable-optionals","title":"\ud83e\uddee Nullable &amp; Optionals","text":"C# Rust <code>T?</code> <code>Option&lt;T&gt;</code> <code>null</code> <code>None</code> <code>HasValue</code> / <code>.Value</code> <code>is_some()</code>, <code>.unwrap()</code>"},{"location":"reverse-mapping/#exceptions-and-errors","title":"\ud83e\udde0 Exceptions and Errors","text":"C# Rust <code>try/catch</code> <code>Result&lt;T, E&gt;</code> + <code>?</code> <code>throw new Exception()</code> <code>panic!()</code> or <code>Err(...)</code> <code>using</code> or <code>IDisposable</code> <code>Drop</code> trait"},{"location":"reverse-mapping/#async-and-concurrency","title":"\ud83d\ude80 Async and Concurrency","text":"C# Rust <code>async Task&lt;T&gt;</code> <code>async fn -&gt; T</code> <code>await</code> <code>.await</code> <code>Task.Run()</code> <code>tokio::spawn()</code> <code>lock(obj)</code> <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> <code>Thread t = new()</code> <code>std::thread::spawn()</code>"},{"location":"reverse-mapping/#project-build-system","title":"\u2699\ufe0f Project &amp; Build System","text":"C# (.NET) Rust <code>.csproj</code> <code>Cargo.toml</code> <code>dotnet build</code> <code>cargo build</code> <code>dotnet test</code> <code>cargo test</code> <code>dotnet run</code> <code>cargo run</code> NuGet <code>crates.io</code>"},{"location":"reverse-mapping/#summary","title":"\ud83d\udcdd Summary","text":"C# Concept Rust Equivalent <code>interface</code> <code>trait</code> <code>List&lt;T&gt;</code> <code>Vec&lt;T&gt;</code> <code>T?</code> <code>Option&lt;T&gt;</code> <code>try/catch</code> <code>Result&lt;T, E&gt;</code> <code>Task&lt;T&gt;</code> <code>async fn -&gt; T</code> <code>DllImport</code> <code>extern \"C\"</code> + <code>#[no_mangle]</code> <p>This reverse map is ideal for .NET developers starting their Rust journey.</p>"},{"location":"serialization/","title":"\ud83e\uddfe Serialization &amp; Deserialization: Rust vs C","text":"<p>Both Rust and C# provide flexible ways to serialize and deserialize data into formats like JSON, binary, and more.</p>"},{"location":"serialization/#rust-serde-crate","title":"\ud83e\udd80 Rust: <code>serde</code> Crate","text":""},{"location":"serialization/#add-dependencies","title":"Add Dependencies","text":"<pre><code>[dependencies]\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\n</code></pre>"},{"location":"serialization/#json-example","title":"JSON Example","text":"<pre><code>use serde::{Serialize, Deserialize};\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct Person {\n    name: String,\n    age: u8,\n}\n\nlet json = r#\"{\"name\":\"Alice\",\"age\":30}\"#;\nlet person: Person = serde_json::from_str(json)?;\nprintln!(\"{:?}\", person);\n\nlet output = serde_json::to_string(&amp;person)?;\nprintln!(\"{}\", output);\n</code></pre>"},{"location":"serialization/#c-systemtextjson-newtonsoftjson","title":"\ud83d\udcbb C#: System.Text.Json / Newtonsoft.Json","text":""},{"location":"serialization/#with-systemtextjson-built-in-since-net-core-30","title":"With <code>System.Text.Json</code> (built-in since .NET Core 3.0)","text":"<pre><code>using System.Text.Json;\n\npublic class Person {\n    public string Name { get; set; }\n    public byte Age { get; set; }\n}\n\nvar json = \"{\"Name\":\"Alice\",\"Age\":30}\";\nvar person = JsonSerializer.Deserialize&lt;Person&gt;(json);\nConsole.WriteLine(person.Name);\n\nvar output = JsonSerializer.Serialize(person);\nConsole.WriteLine(output);\n</code></pre>"},{"location":"serialization/#with-newtonsoftjson-popular-library","title":"With <code>Newtonsoft.Json</code> (popular library)","text":"<pre><code>dotnet add package Newtonsoft.Json\n</code></pre> <pre><code>using Newtonsoft.Json;\n\nvar person = JsonConvert.DeserializeObject&lt;Person&gt;(json);\nvar output = JsonConvert.SerializeObject(person);\n</code></pre>"},{"location":"serialization/#binary-formats","title":"\ud83e\uddec Binary Formats","text":""},{"location":"serialization/#rust-bincode","title":"Rust: <code>bincode</code>","text":"<pre><code>[dependencies]\nbincode = \"1.3\"\n</code></pre> <pre><code>let encoded: Vec&lt;u8&gt; = bincode::serialize(&amp;person)?;\nlet decoded: Person = bincode::deserialize(&amp;encoded)?;\n</code></pre>"},{"location":"serialization/#c-binary-serialization","title":"C#: Binary Serialization","text":"<pre><code>using System.Runtime.Serialization.Formatters.Binary;\n\n// \u26a0\ufe0f Obsolete: use protobuf, MessagePack, etc. for modern binary\n</code></pre>"},{"location":"serialization/#advanced-features","title":"\ud83e\udde0 Advanced Features","text":"Feature Rust (<code>serde</code>) C# (<code>System.Text.Json</code>) Custom field rename <code>#[serde(rename = \"...\")]</code> <code>[JsonPropertyName(\"...\")]</code> Skipping fields <code>#[serde(skip)]</code> <code>[JsonIgnore]</code> Conditional logic <code>with</code>, <code>skip_serializing_if</code> Converters / Conditionals Binary formats <code>bincode</code>, <code>postcard</code> <code>protobuf</code>, <code>MessagePack</code> Field defaults <code>#[serde(default)]</code> <code>[JsonIgnore(Condition = ...)]</code>"},{"location":"serialization/#summary","title":"\u2705 Summary","text":"Task Rust C# JSON support <code>serde_json</code> <code>System.Text.Json</code> or <code>Newtonsoft.Json</code> Binary support <code>bincode</code>, <code>postcard</code> <code>BinaryFormatter</code>, <code>protobuf</code>, etc. Field annotations <code>#[serde(...)]</code> <code>[JsonPropertyName]</code>, <code>[JsonIgnore]</code> Common usage <code>derive(Serialize)</code> POCO classes, <code>JsonSerializer</code> API <p>Rust gives you fine-grained control through macros and derive annotations, while C# offers integrated JSON support with attribute-driven customization.</p>"},{"location":"structs-enums/","title":"\ud83e\uddf1 Structs &amp; Enums","text":""},{"location":"structs-enums/#structs","title":"\ud83d\udcd0 Structs","text":"<pre><code>struct Point {\n    x: f32,\n    y: f32,\n}\n</code></pre> <pre><code>struct Point {\n    public float X;\n    public float Y;\n}\n</code></pre>"},{"location":"structs-enums/#enums","title":"\ud83c\udfaf Enums","text":"<pre><code>enum Direction {\n    Up,\n    Down,\n    Left,\n    Right,\n}\n</code></pre> <pre><code>enum Direction {\n    Up,\n    Down,\n    Left,\n    Right\n}\n</code></pre>"},{"location":"structs-enums/#example-usage","title":"\ud83e\uddea Example Usage","text":"<pre><code>let d = Direction::Left;\n</code></pre> <pre><code>Direction d = Direction.Left;\n</code></pre>"},{"location":"testing/","title":"\ud83e\uddea Testing","text":""},{"location":"testing/#unit-tests","title":"\ud83d\udd0d Unit Tests","text":"Rust C# <code>#[test]</code> <code>[TestMethod]</code> or <code>[Fact]</code> <code>assert_eq!(a, b)</code> <code>Assert.AreEqual(a, b)</code>"},{"location":"testing/#example","title":"\ud83e\uddea Example","text":"<pre><code>#[test]\nfn it_adds() {\n    assert_eq!(2 + 2, 4);\n}\n</code></pre> <pre><code>[TestMethod]\npublic void ItAdds() {\n    Assert.AreEqual(4, 2 + 2);\n}\n</code></pre>"},{"location":"testing/#exception-testing","title":"\ud83e\uddea Exception Testing","text":""},{"location":"testing/#rust","title":"Rust","text":"<pre><code>#[test]\n#[should_panic(expected = \"division by zero\")]\nfn it_panics() {\n    let _ = 1 / 0;\n}\n</code></pre>"},{"location":"testing/#c","title":"C#","text":"<pre><code>[Fact]\npublic void ItPanics() {\n    Assert.Throws&lt;DivideByZeroException&gt;(() =&gt; {\n        var x = 1 / 0;\n    });\n}\n</code></pre>"},{"location":"testing/#capturing-output-in-rust","title":"\ud83d\udd0d Capturing Output in Rust","text":"<pre><code>cargo test -- --nocapture\n</code></pre>"},{"location":"tooling-comparison/","title":"\ud83d\udd27 Tooling Comparison","text":""},{"location":"tooling-comparison/#common-commands","title":"\ud83d\udee0 Common Commands","text":"Purpose Rust C# (.NET CLI) Build <code>cargo build</code> <code>dotnet build</code> Test <code>cargo test</code> <code>dotnet test</code> Format <code>rustfmt</code> <code>dotnet format</code> Docs <code>cargo doc</code> <code>DocFX</code>, XML comments"},{"location":"tooling-comparison/#example-scripts","title":"\ud83e\uddea Example Scripts","text":""},{"location":"tooling-comparison/#rust","title":"Rust","text":"<pre><code>cargo build --release\ncargo test --all\n</code></pre>"},{"location":"tooling-comparison/#c-net-cli","title":"C# .NET CLI","text":"<pre><code>dotnet build -c Release\ndotnet test\n</code></pre>"},{"location":"traits-interfaces/","title":"\ud83e\udde9 Traits vs Interfaces","text":""},{"location":"traits-interfaces/#interface-definition","title":"\ud83e\udde9 Interface Definition","text":"Rust C# <code>trait Drawable { ... }</code> <code>interface IDrawable {}</code>"},{"location":"traits-interfaces/#example","title":"\ud83e\uddea Example","text":"<pre><code>trait Drawable {\n    fn draw(&amp;self);\n}\n</code></pre> <pre><code>public interface IDrawable {\n    void Draw();\n}\n</code></pre>"},{"location":"traits-interfaces/#implementation","title":"\ud83d\udee0 Implementation","text":"Rust C# <code>impl Drawable for Circle {}</code> <code>class Circle : IDrawable {}</code>"},{"location":"traits-interfaces/#example_1","title":"\ud83e\uddea Example","text":"<pre><code>struct Circle;\n\nimpl Drawable for Circle {\n    fn draw(&amp;self) {\n        println!(\"Drawing circle!\");\n    }\n}\n</code></pre> <pre><code>public class Circle : IDrawable {\n    public void Draw() {\n        Console.WriteLine(\"Drawing circle!\");\n    }\n}\n</code></pre>"},{"location":"writing-binary-data/","title":"\ud83d\udcdd Writing Binary Data: Rust vs C","text":"<p>This guide compares techniques for writing binary data to files and streams in Rust and C#, including primitives, arrays, strings, and structs.</p>"},{"location":"writing-binary-data/#file-writer-setup","title":"\ud83d\uddc2 File Writer Setup","text":"Rust C# <code>let file = File::create(path)?;</code> <code>var stream = new FileStream(path, FileMode.Create);</code> <code>let mut writer = BufWriter::new(file);</code> <code>var writer = new BinaryWriter(stream);</code>"},{"location":"writing-binary-data/#writing-primitive-types","title":"\ud83d\udd22 Writing Primitive Types","text":""},{"location":"writing-binary-data/#rust","title":"\ud83e\udd80 Rust","text":"<pre><code>use byteorder::{WriteBytesExt, LittleEndian};\n\nwriter.write_u32::&lt;LittleEndian&gt;(42)?;\nwriter.write_f32::&lt;LittleEndian&gt;(3.14)?;\n</code></pre>"},{"location":"writing-binary-data/#c","title":"\ud83d\udcbb C#","text":"<pre><code>writer.Write((uint)42);\nwriter.Write(3.14f);\n</code></pre>"},{"location":"writing-binary-data/#writing-with-endianness","title":"\ud83d\udccf Writing With Endianness","text":"Rust C# Uses <code>byteorder</code> crate Must reverse bytes manually"},{"location":"writing-binary-data/#c-bigendian-example","title":"\ud83d\udca1 C# BigEndian Example","text":"<pre><code>byte[] bytes = BitConverter.GetBytes(42);\nArray.Reverse(bytes); // BigEndian\nwriter.Write(bytes);\n</code></pre>"},{"location":"writing-binary-data/#writing-strings","title":"\ud83e\uddf5 Writing Strings","text":"Format Rust C# Null-terminated Write UTF-8 then <code>0</code> byte Encode + Write + WriteByte Pascal-style Prefix length (u8/u16) Write length + bytes"},{"location":"writing-binary-data/#rust-null-terminated","title":"\ud83e\udd80 Rust (null-terminated)","text":"<pre><code>writer.write_all(\"Hello\".as_bytes())?;\nwriter.write_u8(0)?;\n</code></pre>"},{"location":"writing-binary-data/#c-null-terminated","title":"\ud83d\udcbb C# (null-terminated)","text":"<pre><code>writer.Write(Encoding.UTF8.GetBytes(\"Hello\"));\nwriter.Write((byte)0);\n</code></pre>"},{"location":"writing-binary-data/#writing-arrays-and-structs","title":"\ud83e\uddf1 Writing Arrays and Structs","text":""},{"location":"writing-binary-data/#rust_1","title":"\ud83e\udd80 Rust","text":"<pre><code>let data = [1u8, 2, 3, 4];\nwriter.write_all(&amp;data)?;\n</code></pre>"},{"location":"writing-binary-data/#c_1","title":"\ud83d\udcbb C#","text":"<pre><code>byte[] data = { 1, 2, 3, 4 };\nwriter.Write(data);\n</code></pre>"},{"location":"writing-binary-data/#writing-a-custom-struct","title":"\ud83e\udde9 Writing a Custom Struct","text":""},{"location":"writing-binary-data/#rust_2","title":"Rust","text":"<pre><code>struct Header {\n    id: u32,\n    version: u16,\n}\n\nimpl Header {\n    fn write_to(&amp;self, w: &amp;mut impl Write) -&gt; std::io::Result&lt;()&gt; {\n        w.write_u32::&lt;LittleEndian&gt;(self.id)?;\n        w.write_u16::&lt;LittleEndian&gt;(self.version)?;\n        Ok(())\n    }\n}\n</code></pre>"},{"location":"writing-binary-data/#c_2","title":"C#","text":"<pre><code>struct Header {\n    public uint Id;\n    public ushort Version;\n\n    public void WriteTo(BinaryWriter writer) {\n        writer.Write(Id);\n        writer.Write(Version);\n    }\n}\n</code></pre>"},{"location":"writing-binary-data/#full-example","title":"\ud83e\uddea Full Example","text":""},{"location":"writing-binary-data/#rust_3","title":"Rust","text":"<pre><code>let mut file = BufWriter::new(File::create(\"data.bin\")?);\nfile.write_u32::&lt;LittleEndian&gt;(0xDEADBEEF)?;\nfile.write_all(b\"DATA\")?;\nfile.write_u8(0)?;\n</code></pre>"},{"location":"writing-binary-data/#c_3","title":"C#","text":"<pre><code>using var fs = new FileStream(\"data.bin\", FileMode.Create);\nusing var writer = new BinaryWriter(fs);\nwriter.Write(0xDEADBEEF);\nwriter.Write(Encoding.ASCII.GetBytes(\"DATA\"));\nwriter.Write((byte)0);\n</code></pre>"},{"location":"writing-binary-data/#summary","title":"\u2705 Summary","text":"Task Rust C# Create writer <code>BufWriter::new(File::create(...))</code> <code>new BinaryWriter(FileStream)</code> Write primitive <code>write_u32::&lt;LE&gt;(val)</code> <code>writer.Write(val)</code> Endianness <code>byteorder</code> crate Manual byte swap Write string <code>write_all() + 0</code> <code>Write(bytes) + Write((byte)0)</code> Write struct Implement <code>write_to()</code> Define <code>WriteTo(BinaryWriter)</code> <p>This section helps you build binary file serializers, network packets, or game data writers across Rust and C#.</p>"}]}